/**
 * From 2.8
 * TypeScript 2.8引入了有条件类型，它能够表示非统一的类型。 有条件的类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：
 *      T extends U ? X : Y
 * 上面的类型意思是，若T能够赋值给U，那么类型是X，否则为Y。
 *
 * 有条件的类型T extends U ? X : Y或者解析为X，或者解析为Y，再或者延迟解析，因为它可能依赖一个或多个类型变量。
 * 是否直接解析或推迟取决于：
 *      1. 首先，令T'和U'分别为T和U的实例，并将所有类型参数替换为any，如果T'不能赋值给U'，则将有条件的类型解析成Y。
 *      直观上讲，如果最宽泛的T的实例不能赋值给最宽泛的U的实例，那么我们就可以断定不存在可以赋值的实例，因此可以解析为Y。
 *
 *      2. 其次，针对每个在U内由推断声明引入的类型变量，依据从T推断到U来收集一组候选类型（使用与泛型函数类型推断相同的推断算法）。
 *      对于给定的推断类型变量V，如果有候选类型是从协变的位置上推断出来的，
 *      那么V的类型是那些候选类型的联合。反之，如果有候选类型是从逆变的位置上推断出来的，那么V的类型是那些候选类型的交叉类型。否则V的类型是never。
 *
 *      3. 然后，令T''为T的一个实例，所有推断的类型变量用上一步的推断结果替换，如果T''明显可赋值给U，那么将有条件的类型解析为X。
 *      除去不考虑类型变量的限制之外，明显可赋值的关系与正常的赋值关系一致。直观上，当一个类型明显可赋值给另一个类型，我们就能够知道它可以赋值给那些类型的所有实例。
 *
 *      4. 否则，这个条件依赖于一个或多个类型变量，有条件的类型解析被推迟进行。
 * */
{
}
{
    class Animal {
    }
    class Dog extends Animal {
    }
    class Corgi extends Dog {
    }
}
/**
 * 分布式有条件类型
 * 如果有条件类型里待检查的类型是naked type parameter，那么它也被称为“分布式有条件类型”。 分布式有条件类型在实例化时会自动分发成联合类型。
 * 例如，实例化T extends U ? X : Y，T的类型为A | B | C，会被解析为(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)。
 *
 * 也就是如果 T 为联合类型 就会 联合的每个类型 都会分别判断 然后 在联合在一起
 * */
{
}
/**
 * 在T extends U ? X : Y的实例化里，对T的引用被解析为联合类型的一部分（比如，T指向某一单个部分，在有条件类型分布到联合类型之后）。
 * 此外，在X内(也就是 true 的分支内 使用的T 是被 U 类型所约束的) 对T的引用有一个附加的类型参数约束U（例如，T被当成在X内可赋值给U）。
 * */
{
}
/**
 * 有条件类型的分布式的属性可以方便地用来过滤联合类型
 * */
{
    function f1(x, y) {
        x = y; // Ok
        // y = x;  // Error
    }
    function f2(x, y) {
        x = y; // Ok
        // y = x;  // Error
        // let s1: string = x;  // Error
    }
}
/**
 * 有条件类型与映射类型结合时特别有用
 * */
{
}
/**
 * 与联合类型和交叉类型相似，有条件类型不允许递归地引用自己。比如下面的错误。
 * */
{
    // type ElementType<T> = T extends any[] ? ElementType<T[number]> : T;  // Error 不允许递归自己
}
/**
 * 有条件类型中的类型推断
 *
 * 现在在有条件类型的extends子语句中，允许出现infer声明，它会引入一个待推断的类型变量。
 * 这个推断的类型变量可以在有条件类型的true分支中被引用。
 * 允许出现多个同类型变量的infer。
 * */
{
}
{
}
//# sourceMappingURL=2.8 有条件类型.js.map