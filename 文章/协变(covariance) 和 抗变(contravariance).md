# 什么是 协变 和 抗变(逆变)

### 本文的专业术语
* A ≼ B 代表 B是A的子类型。
* A → B 代表函数 参数是A类型，返回B类型。
* x:A 代表 x 为 类型A 的别名.

## 一个问题
假设有一下三种类型   
`灵𤟥 ≼ 狗 ≼ 动物`

所以 灵𤟥 是 狗的子类型, 狗是 动物的子类型. 子类型又是传递的,所以  
灵𤟥 也是 动物的子类型  

**问题** 下面那一个类型 是 `狗 → 狗` 的子类型
1. `灵𤟥 → 灵𤟥 `
2. `灵𤟥 → 动物`
3. `动物 → 动物`
4. `动物 → 灵𤟥`

设 `f` 是一个 以`狗 → 狗`函数 为参数的函数,
我们不关心返回值的类型(假设为string) :  
`f: (狗 → 狗) → string`  
我们现在 用 `g` 作为参数 传入 `f` 来调用

1. 假设 `g` : `灵𤟥 → 灵𤟥`. `f(g)` 类型安全吗?    
   不安全 因为 `f` 可能中会 尝试 使用不同的 `狗` 的子类型 调用 `g`
   如 `德国牧羊犬`  

2. 假设 `g` : `灵𤟥 → 动物`. `f(g)` 类型安全吗?  
   不安全, 原因同 1
      
3.  假设 `g` : `动物 → 动物`. `f(g)` 类型安全吗?  
    不安全,因为 `f` 中可能 调用 `g`
    然后使用返回值(`动物`类型)犬吠方法.
    不是所有的`动物`都有犬吠方法.
    
4. 假设 `g` : `动物 → 灵𤟥`. `f(g)` 类型安全吗?  
   安全. 因为`f` 中能够 调用 `g` 用任何`狗`类型的参数.
   因为所有的`狗` 都是 `动物`.同样的, 对于返回值 `狗`
   所有的`灵𤟥`一定都是`狗`
   
## 这是为什么呢
所以这样是安全的:   
` (动物 → 灵𤟥) ≼ ( 狗 → 狗) `   
返回类型很明显: `灵𤟥` 是 `狗` 的子类型.但是 参数却相反 `动物` 是
`狗` 的父类型


为了用正确的术语来解释这种奇怪的行为.我们允许函数类型在它们的返回类型中是**协变**的，
并且在它们的参数类型中是**抗变**的. 
返回类型中**协变**代表`A ≼ B`意味着`(T → A) ≼ (T → B)`(`A`保持在左侧,`B`保持在右侧).
参数类型**抗变**代表`A ≼ B`意味着`(B → T) ≼ (A → T)`(`B`保持在左侧,`A`保持在右侧).


> Typescript 已经在 2.6 版本修复了 函数参数 双变(既能抗变 有能 协变)的问题
 
 
 ## 对于其他的类型呢?
 **问题** `List<狗>` 是 `List<动物>` 的子类型吗?
 
这个答案 有点微妙.如果 list 实例是不可变的,那么是类型安全的. 如果是可变的那么就是类型不安全的.  

为什么呢? 假设我们需要一个 `List<动物>`类型 然后 传递过来的是一个 `List<狗>`类型.
既然我认为我有`List<动物>`，我可能会尝试插入一个`猫`。现在你`List<狗>`有一个`猫`！类型系统不应该允许这样做。


形式上来讲: 我们可以允许不可变列表的类型在其类型参数中是协变的，
但是可变列表的类型在其类型参数中必须是不变的（既不是协变也不是逆变）。

> 在Java中，数组是可变的和协变的。这当然是不健全的。  
> 然而 Typescript 的 Array 也是, 数组是可变的和协变的

[原文地址](https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance)
